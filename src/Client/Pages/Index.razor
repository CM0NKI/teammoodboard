@page "/"
@page "/{moodboardIdParameter}"
@using Models
@using MoodBoard.Shared;
@using Microsoft.AspNetCore.SignalR.Client
@inject NavigationManager NavigationManager
@implements IAsyncDisposable

@if (client.Initialised)
{
    <div class="container">
        @foreach (var topic in client.Moodboard.Configuration.Topics)
        {
            <div class="topic">@topic.Name <span class="voteCount">@GetVoteCountForTopic(topic.Id)</span></div>
            @foreach (var option in client.Moodboard.Configuration.Options)
            {
                if (AlreadyVoted(topic.Id, option.Id))
                {
                    <div class="option voted">
                        @option.Emoji <span class="voteCount">@GetVoteCountForOption(topic.Id, option.Id)</span>
                    </div>
                }
                else
                {
                    <div class="option"
                        @onclick="() => ProcessVote(topic.Id, option.Id)">
                            @option.Emoji <span class="voteCount">@GetVoteCountForOption(topic.Id, option.Id)</span>
                    </div>                    
                }
            }
        }
    </div>
}

@code {
    [Parameter]
    public string moodboardIdParameter { get; set; }

    private Client client = new()
    {
        SessionId = Guid.NewGuid(),
        Initialised = false,
        HubConnection = null,
        Moodboard = null
    };

    protected override async Task OnInitializedAsync()
    {
        client.HubConnection = await InitialiseHubConnection();
        client.Moodboard = await InitialiseMoodboard();

        NavigationManager.NavigateTo($"/{client.Moodboard.Id}");
        client.Initialised = true;
    }

    async Task<HubConnection> InitialiseHubConnection()
    {
        var hubConnection = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri("/moodboardHub"))
            .WithAutomaticReconnect()
            .Build();
        hubConnection.On<Moodboard>("MoodboardUpdate", (moodboard) => ProcessUpdateFromHub(moodboard));
        await hubConnection.StartAsync();
        return hubConnection;
    }

    async Task<Moodboard> InitialiseMoodboard()
    {
        Guid moodboardId;
        var validMoodboardIdFound = Guid.TryParse(moodboardIdParameter, out moodboardId);

        if (!validMoodboardIdFound)
            moodboardId = Guid.NewGuid();
            
        return await client.HubConnection.InvokeAsync<Moodboard>("RegisterNewClient", moodboardId);
    }    

    void ProcessUpdateFromHub(Moodboard moodboard)
    {
        client.Moodboard = moodboard;
        StateHasChanged();
    }

    int GetVoteCountForTopic(int topicId)
    {
        return client.Moodboard.Votes.Count(vote => vote.TopicId == topicId);
    }

    int GetVoteCountForOption(int topicId, int optionId)
    {
        return client.Moodboard.Votes.Count(vote => 
            vote.TopicId == topicId && vote.OptionId == optionId);
    }    

    bool AlreadyVoted(int topicId, int optionId)
    {
        return client.Moodboard.Votes.Any(vote =>
            vote.ClientSessionId == client.SessionId
            && vote.TopicId == topicId
            && vote.OptionId == optionId);
    }

    async Task ProcessVote(int topicId, int optionId)
    {
        var existingVoteForSameTopic = client.Moodboard.Votes.Where(vote => 
            vote.ClientSessionId == client.SessionId 
            && vote.TopicId == topicId).SingleOrDefault();

        if (existingVoteForSameTopic != null)
            client.Moodboard.Votes.Remove(existingVoteForSameTopic);

        client.Moodboard.Votes.Add(new Vote(client.SessionId, topicId, optionId));
        await client.HubConnection.SendAsync("ProcessUpdatedMoodboard", client.Moodboard);
    }

    public ValueTask DisposeAsync() =>
        client.HubConnection.DisposeAsync();
}