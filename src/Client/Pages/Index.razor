@page "/"
@page "/{moodboardIdParameter}"
@using MoodBoard.Models;
@using MoodBoard.Shared;
@using Microsoft.AspNetCore.SignalR.Client
@inject NavigationManager NavigationManager
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage
@implements IAsyncDisposable

@if (client.Initialised)
{
    @foreach (var topic in client.Moodboard.Configuration.Topics)
    {
        <div class="emoji-picker" style="margin-bottom: 3rem;">
            <div class="topic @(animateTopicForTopic.ContainsKey(topic.Id) && animateTopicForTopic[topic.Id] ? "animate" : "")"
                 @onclick="() => ShowAllEmojis(topic.Id)">@topic.Name</div>

            <!-- Horizontal layout for emojis -->
            <div class="emoji-container">
                @foreach (var option in client.Moodboard.Configuration.Options)
                {
                    var isSelected = AlreadyVoted(client.SessionId, topic.Id, option.Id);
                    var voteCount = GetVoteCountForOption(topic.Id, option.Id);
                    var showVoteCount = showVoteCountForTopic.ContainsKey(topic.Id) && showVoteCountForTopic[topic.Id];

                    <div class="emojiIcon">
                        <span>@option.Emoji</span>
                        <div class="emojiText">@option.Description</div>
                    </div>
                }
            </div>
        </div>
    }
}
else
{
    <div>Loading...</div>
}

@code {

[Parameter]
public string moodboardIdParameter { get; set; }

private Client client = new()
{
    HubConnection = null,
    Moodboard = null,
    SessionId = Guid.Empty,
    Initialised = false
};

private Dictionary<int, bool> showAllEmojisForTopic = new();
private Dictionary<int, bool> animateTopicForTopic = new();
private Dictionary<int, bool> showVoteCountForTopic = new();

protected override async Task OnInitializedAsync()
{
    client.HubConnection = await InitialiseHubConnection();
    client.Moodboard = await InitialiseMoodboard();
    client.SessionId = await InitialiseSessionId(client.Moodboard.Id);

    // Initialize state for all topics
    foreach (var topic in client.Moodboard.Configuration.Topics)
    {
        showAllEmojisForTopic[topic.Id] = true; // Start with emojis visible
        animateTopicForTopic[topic.Id] = false;
        showVoteCountForTopic[topic.Id] = false; // Start with text visible
    }

    NavigationManager.NavigateTo($"/{client.Moodboard.Id}");
    await SaveSessionInLocalStorage(client.Moodboard.Id, client.SessionId);
    client.Initialised = true;
}

async Task<Guid> InitialiseSessionId(Guid moodboardId)
{
    var existingSessionId = await LocalStorage.GetItemAsync<Guid>(moodboardId.ToString());
    if (existingSessionId != Guid.Empty)
        return existingSessionId;
    else
        return Guid.NewGuid();
}

async Task<HubConnection> InitialiseHubConnection()
{
    var hubConnection = new HubConnectionBuilder()
        .WithUrl(NavigationManager.ToAbsoluteUri("/moodboardHub"))
        .WithAutomaticReconnect()
        .Build();
    hubConnection.On<Moodboard>("MoodboardUpdate", (moodboard) => ProcessUpdateFromHub(moodboard));
    await hubConnection.StartAsync();
    return hubConnection;
}

async Task<Moodboard> InitialiseMoodboard()
{
    var validMoodboardIdFound = Guid.TryParse(moodboardIdParameter, out var moodboardId);

    if (!validMoodboardIdFound)
        moodboardId = Guid.NewGuid();
            
    return await client.HubConnection.InvokeAsync<Moodboard>("RegisterNewClient", moodboardId);
}

async Task SaveSessionInLocalStorage(Guid moodboardId, Guid sessionId)
{
    await LocalStorage.SetItemAsync<Guid>(moodboardId.ToString(), sessionId);
}    

void ProcessUpdateFromHub(Moodboard moodboard)
{
    client.Moodboard = moodboard;
    StateHasChanged();
}

int GetVoteCountForOption(int topicId, int optionId)
{
    return client.Moodboard.Votes.Count(vote => 
        vote.TopicId == topicId && vote.OptionId == optionId);
}    

bool AlreadyVoted(Guid sessionId, int topicId, int optionId)
{
    return client.Moodboard.Votes.Any(vote =>
        vote.ClientSessionId == sessionId
        && vote.TopicId == topicId
        && vote.OptionId == optionId);
}

async Task ProcessVote(Guid sessionId, int topicId, int optionId)
{
    var newVote = new Vote(sessionId, topicId, optionId);

    var existingVoteForSameTopic = client.Moodboard.Votes.Where(vote => 
        vote.ClientSessionId == sessionId
        && vote.TopicId == topicId).SingleOrDefault();

    if (existingVoteForSameTopic == newVote)
        return;

    if (existingVoteForSameTopic != null)
        client.Moodboard.Votes.Remove(existingVoteForSameTopic);

    client.Moodboard.Votes.Add(newVote);
    
    // Show vote counts for this topic when user clicks an emoji
    showVoteCountForTopic[topicId] = true;
    
    // Trigger topic animation
    await TriggerTopicAnimation(topicId);
    
    await client.HubConnection.SendAsync("ProcessUpdatedMoodboard", client.Moodboard);
}

void ShowAllEmojis(int topicId)
{
    showAllEmojisForTopic[topicId] = true;
    StateHasChanged();
}

void ShowResults(int topicId)
{
    showAllEmojisForTopic[topicId] = false;
    // Keep showing vote counts once user has voted for this topic
    StateHasChanged();
}

bool HasSelectedEmoji(int topicId)
{
    return client.Moodboard.Votes.Any(vote => 
        vote.ClientSessionId == client.SessionId && vote.TopicId == topicId);
}

async Task TriggerTopicAnimation(int topicId)
{
    // Remove animation class first
    animateTopicForTopic[topicId] = false;
    StateHasChanged();
    
    // Force a reflow
    await Task.Delay(1);
    
    // Add animation class
    animateTopicForTopic[topicId] = true;
    StateHasChanged();
    
    // Remove animation class after animation completes (0.6s duration)
    await Task.Delay(600);
    animateTopicForTopic[topicId] = false;
    StateHasChanged();
}

public ValueTask DisposeAsync() =>
    client.HubConnection.DisposeAsync();

}